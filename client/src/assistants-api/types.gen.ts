// This file is auto-generated by @hey-api/openapi-ts

export type CreateAssistantRequest = {
    /**
     * Name of this configuration. So the combination of model type + weights + params can
     * be identified as e.g. `zim-x-ray-small`.
     */
    assistant_name: string;
    /**
     * Type of the model
     */
    assistant_type: 'sam2' | 'zim';
    /**
     * Additional parameters the model's config should recognize. For ZIM, it's just a
     * `checkpoint` parameter pointing to a folder with encoder/decoder onnx weights. For
     * SAM2, you must pass `ckpt_path` and `config_file` pointing to the model's weights
     * and config file.
     *
     * If None, each asset's filename is used as a parameter key, and the asset's content
     * is used as the parameter value.
     */
    config_parameters?: ({
    [key: string]: unknown;
} | null);
    /**
     * Files referenced by name in the parameters. If a zip file is provided, it is
     * extracted maintaining directories.
     */
    assets: Array<((Blob | File))>;
};

/**
 * Type of the model
 */
export type assistant_type = 'sam2' | 'zim';

/**
 * Type of the model
 */
export const assistant_type = {
    SAM2: 'sam2',
    ZIM: 'zim'
} as const;

export type GetAssistantsResponse = {
    assistants: Array<{
        [key: string]: unknown;
    }>;
    page: number;
    pagination: {
        [key: string]: unknown;
    };
};

export type HTTPValidationError = {
    detail?: Array<ValidationError>;
};

export type SAM2Parameters = {
    mask_threshold?: number;
    max_hole_area?: number;
    max_sprinkle_area?: number;
};

export type SAM2SegmentationRequest = {
    /**
     * Name of the model to use
     */
    assistant_name: string;
    /**
     * Image to be segmented
     */
    image: (Blob | File);
    /**
     * List of (x, y) points to consider as foreground
     */
    foreground_xy: Array<Array<(number)>>;
    /**
     * Relevant additional parameters for this iteration of segmentation
     */
    parameters: (string | SAM2Parameters);
};

export type SegmentationResult = {
    disabled: boolean;
    segmentation: Array<Array<(number)>>;
    message?: string;
};

export type ValidationError = {
    loc: Array<(string | number)>;
    msg: string;
    type: string;
};

export type ZIMParameters = {
    [key: string]: unknown;
};

export type ZimSegmentationRequest = {
    /**
     * Name of the model to use
     */
    assistant_name: string;
    /**
     * Image to be segmented
     */
    image: (Blob | File);
    /**
     * List of (x, y) points to consider as foreground
     */
    foreground_xy: Array<Array<(number)>>;
    /**
     * Relevant additional parameters for this iteration of segmentation
     */
    parameters: (string | ZIMParameters);
};

export type GetAssistantsData = {
    query?: {
        /**
         * Name of the configuration to retrieve
         */
        assistant_name?: (string | null);
        /**
         * Type of the model
         */
        assistant_type?: ('sam2' | 'zim' | null);
        /**
         * Page number to retrieve
         */
        page?: number;
        /**
         * Number of items per page. If None, all items are returned
         */
        page_size?: (number | null);
    };
};

export type GetAssistantsResponse2 = (GetAssistantsResponse);

export type GetAssistantsError = (HTTPValidationError);

export type CreateAssistantData = {
    body: CreateAssistantRequest;
};

export type CreateAssistantResponse = (unknown);

export type CreateAssistantError = (HTTPValidationError);

export type DeleteAssistantData = {
    path: {
        assistant_id: string;
    };
};

export type DeleteAssistantResponse = (unknown);

export type DeleteAssistantError = (HTTPValidationError);

export type GetDummyAssistantsResponse = (unknown);

export type GetDummyAssistantsError = unknown;

export type ZimSegmentationData = {
    body: ZimSegmentationRequest;
};

export type ZimSegmentationResponse = (SegmentationResult);

export type ZimSegmentationError = (HTTPValidationError);

export type Sam2SegmentationData = {
    body: SAM2SegmentationRequest;
};

export type Sam2SegmentationResponse = (SegmentationResult);

export type Sam2SegmentationError = (HTTPValidationError);